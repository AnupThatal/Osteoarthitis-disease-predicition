# -*- coding: utf-8 -*-
"""VGG16_Algo_Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ND1jYznlQRAVYt4BM-ZNk6lEtTmRuosf
"""

#importing all the necessary library
import matplotlib.pyplot as plt
import numpy as np 
import cv2
import os
import keras
import tensorflow as tf 
from keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications.vgg16 import preprocess_input

# We use float32 as a dtatype to rescale the image.
#In this step we are preforming preprocessing_function from vgg16 library. Preprocessing_input job is to make fit to be trained in Vgg16 algo.

train_datagen=ImageDataGenerator(preprocessing_function=preprocess_input,dtype='float32') #included in our dependencies

test_datagen=ImageDataGenerator(preprocessing_function=preprocess_input,dtype='float32')

#we have read the necessary data from the uploaded folder with the height and width of the 224, and channel is 3-(Red, Green,blue image) 
#also we have shuffled the image with a batch size of 32 & it has a class of 5 which is categorical.

train_generator=train_datagen.flow_from_directory('/content/drive/MyDrive/KneeXray/train',target_size=(224,224),
                                                 color_mode='rgb',
                                                 batch_size=32,
                                                 class_mode='categorical',
                                                  shuffle=True)

test_generator=test_datagen.flow_from_directory('/content/drive/MyDrive/KneeXray/val')

from google.colab import drive
drive.mount('/content/drive')

from tensorflow.keras.applications import VGG16
from tensorflow.keras import layers, Model, Input

image_input = Input(shape=(224,224, 3)) #We have input shape of 224 width, 224 height and channel 3


base_model =VGG16(input_tensor=image_input,include_top=False,weights='imagenet',pooling='avg') #Imported Vgg16 to train the model.

x = base_model.output   #imported the output layer of Vgg16.

# freeze all layers in the base model
for layer in base_model.layers:
  layer= False

# un-freeze the BatchNorm layers
for layer in base_model.layers:
    if "BatchNormalization" in layer.__class__.__name__:
        layer.trainable = True

# add custom layers
# x =tf.keras.layers.GlobalAveragePooling2D()(base_model.output)                             # global spatial average pooling layer
x =tf.keras.layers.Dense(1024, activation='relu',kernel_regularizer=tf.keras.regularizers.l2(0.0001))(x)
x =tf.keras.layers.Dropout(0.4)(x)
x=tf.keras.layers.BatchNormalization()(x,training=False)
x =tf.keras.layers.Dense(5, activation='softmax')(x)

# define new model
model = Model(inputs=image_input, outputs=x)

# We calculate the loss and optimize the image weight.#Adam--Adaptive momentum, there is a gradient decent inorder to acehive the best result we need to optimize the weight.
model.compile(loss="categorical_crossentropy",optimizer=tf.keras.optimizers.Adam(learning_rate=0.0001),metrics=['accuracy'])

from keras import callbacks

my_callbacks=callbacks.EarlyStopping(monitor='val_loss', patience=5, verbose=0, mode='min',restore_best_weights=True)

model.summary()

#To train the model with Epoch of 30 and used the call back function to monitor the validation loss. StepsperEpoch means while training Epoch how many steps your taking to improve the accuracy. 

history=model.fit_generator(train_generator,epochs=30,validation_data=test_generator,shuffle=True,callbacks=[my_callbacks],steps_per_epoch=300)

model.save('mode_vgg16.h5') #Saving the model once you train

from tensorflow.keras.models import load_model 
model=load_model('/content/drive/MyDrive/mode_vgg16.h5')

import cv2
list1=[]
from tensorflow.keras.applications.vgg16 import preprocess_input
img=cv2.imread('/content/drive/MyDrive/KneeXray/val/0/Image_1049.jpg')
image=cv2.resize(img,(224,224))
img1=preprocess_input(image)
list1.append(img1)

import numpy as np

image=np.array(list1)

res=model.predict(image)

res

import matplotlib.pyplot as plt

img=plt.imread('/content/drive/MyDrive/KneeXray/val/0/Image_1049.jpg')
plt.imshow(img)

score=input("enter the doctor accuracy")
score1=int(score)/100
print(score1)

name=['algo','doctor_accuracy']
prediction=[9.9772710e-01,score1]
plt.bar(x=name,height=prediction)

import matplotlib.pyplot as plt

name=['vgg16','resnet','mobilenet']
accuracy=[0.9424,0.9918,0.0945]
plt.bar(x=name,height=accuracy)
plt.title("Training accuracy of 3 algorithm ")

import matplotlib.pyplot as plt

name=['vgg16','resnet','mobilenet']
training_loss=[0.1360,0.0210,1.6705]
plt.bar(x=name,height=training_loss)
plt.title("Training loss of 3 algorithm ")

import matplotlib.pyplot as plt

name=['vgg16','resnet','mobilenet']
val_loss=[0.6461,8.5509,1.8179]
plt.bar(x=name,height=val_loss)
plt.title("val loss of 3 algorithm ")

import matplotlib.pyplot as plt

name=['vgg16','resnet','mobilenet']
val_accuracy=[0.7792,0.3027,0.0527]
plt.bar(x=name,height=val_accuracy)
plt.title("val accuracy of 3 algorithm ")

"""This is a classification report for VGG16, ResNet50"""

import os
import cv2 
classes= os.listdir('/content/drive/MyDrive/KneeXray/val')
classes=['0','1','2','3','4']

from tensorflow.keras.applications.vgg16 import preprocess_input
list1=[]
for i in classes:
 location='/content/drive/MyDrive/KneeXray/val'
 name= os.listdir(location+"/"+i)
 string=location+"/"+i
 for j in name:
   img=cv2.imread(string+"/"+j)
   image=cv2.resize(img,(224,224))
   img1=preprocess_input(image)
   list1.append(img1)

import numpy as np
test=np.array(list1)

res=model.predict(test)

res1=np.argmax(res,axis=1)

resnet50_model=load_model('/content/drive/MyDrive/model.h5')

resnet50_model.summary()

resnet_result=resnet50_model.predict(test)

resenet_res2=np.argmax(resnet_result,axis=1)

from sklearn import metrics
print('Classification Report for vgg16')
print(metrics.classification_report(test_generator.classes,res1))

from sklearn import metrics
print('Classification Report for resnet')
print(metrics.classification_report(test_generator.classes,resenet_res2))

from sklearn import metrics
cm = metrics.confusion_matrix(test_generator.classes,res1)

print("confusion metrics for vgg16\n",cm)

from sklearn import metrics
cm = metrics.confusion_matrix(test_generator.classes,resenet_res2)

print("confusion metrics for resnet \n",cm)

from sklearn.metrics import r2_score
print("r2 score for vgg16 ",r2_score(test_generator.classes,res1))

from sklearn.metrics import r2_score
print("r2 score for resnet",r2_score(test_generator.classes,resenet_res2))

from sklearn.metrics import mean_squared_error
mean_squared_error(test_generator.classes,res1)

from sklearn.metrics import mean_squared_error
mean_squared_error(test_generator.classes,resenet_res2)

from sklearn.metrics import roc_auc_score
roc_auc_score(ytest, y_pred,multi_class='ovr')

from sklearn.preprocessing import label_binarize

ytest = label_binarize(test_generator.classes,classes=[0,1,2,3,4])

y_pred=label_binarize(resenet_res2,classes=[0,1,2,3,4])

from sklearn.metrics import roc_auc_score

roc_auc_score(ytest, y_pred,multi_class='ovr')